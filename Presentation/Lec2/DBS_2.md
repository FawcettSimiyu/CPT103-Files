# DBS lecture 2

![image-20210711034208568](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210711034208568.png)

你好，今天我们会开始学习关系代数。考虑到CPT103这门课一般是在大二开课的，而大多数西浦学生在大二上学期之前还没有正式接触过编程语言比如Python、Java 之类的，应该只写过简单的逻辑循环比如电气大类的学生大一会接触到的乐高编程。当你们开始了大二，有了Java、C++相关的课程，当然也包括这门数据库入门课，从这时候开始，如果你是一个纯正的计算机小白，那么你应该认识到，你并不是在学习某一门语言，你是在通过Java、Python、C++其中的一门语言，来学习编程思想。相信很多人听说过一段话，“当你熟悉了某一门编程语言之后，上手其他语言会非常非常快”，当你在驾校的桑塔纳上面好不容易学会了开自动档的车之后，换一辆特斯拉你难道上手不快吗？当你用Java熟悉了逻辑操作和抽象思考的能力，学习其他语言的门槛就已经被降到最低了。

我之所以在数据库的第二节课开始强调这个概念，是因为从这节课开始的所有内容，都在对我们的现实世界进行抽象，我们要开始学习如何用最精炼的SQL语句，来抽象一些数据操作命令，比如说所有名字长度大于2的人的出生省份。计算机世界的太多操作，实在是太精炼和抽象了，会是很多初学者的痛苦所在，正如大多数人学习Java 的时候会被面向对象的编程思想拦住一样，导致大多数入门玩家需要花相当多的练习，才能慢慢适应。而这个抽象的过程。今天这节课之后我们需要学习的能力就是，如何将自然语言翻译为计算机可以理解的，高度抽象的逻辑表达式。一开始的很多概念，希望大家可以多多在纸上自己手动练习一下，因为这种抽象的能力，必须要自己多动手才能真正学会。

![image-20210711034239324](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210711034239324.png)

关系代数是一种应用在不同关系之间的理论语言，使用关系代数可以在不影响原有数据的基础上，使用关系代数操作符来获取结果。今天这门课就会介绍关系代数中的基本操作，将会从最基本的选择操作和投影操作开始，将投影和选择得到的结果进行进一步操作，从而由底向上介绍更加高级的操作。

![image-20210711034313793](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210711034313793.png)

所谓单项操作，意思就是操作对象是单一关系，还记得一个关系是什么么？对，你可以将一个关系理解为一张表就完事了，比如用户表。

我们将会从选择操作和投影操作来开始关系代数的学习。笼统来讲，如图中所示，选择操作就是选取横向的行，而投影操作就是选取纵向的列，听起来是不是很简单？当你看到selection和projection的操作符的时候可能就不这么觉得了。

![image-20210712084020468](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084020468.png)

![image-20210711034338105](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210711034338105.png)

Selection操作符是西格玛，下标那里的predicate表示的是筛选条件，格式就是简单的逻辑判断式，比如哪个属性大于10000这种，这里的表达式可以是大于小于不等于等操作。而括号里的R带哦表着

接下来我们用一个例子来说明Selection的用法，图中这张表是一个员工职工表，他有以下属性：员工编号，员工姓名，员工职位，性别，员工的生日（Date of Birth)，薪水以及员工所在的部门编号，我现在想要列出所有薪水大于10000的员工，我就可以使用上面这个表达式，首先我要告诉他我操作的关系，也就是表名是Staff，员工表，然后我要跟他说我的操作逻辑是抽一些行，这些行的薪水属性的值必须要大于10000, 满足条件的行就全部返回给我了，正如图中显示的那样，所有的行都是我想要的。

![image-20210711041240033](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210711041240033.png)

选择操作可以实现的逻辑运算包括大于小于不等于等于，同时还包括或且非这三个很重要的逻辑操作符号.

Not就是不等于的意思，很容易理解，而OR则是或者的意思，OR两边的判断只要有一个是正确的，那么最终的表达式就是对的，AND的条件则更加苛刻，只有两边的条件都满足的时候，整个表达式才是正确的。

我们用实际的例子来说明一下。第二个例子中，哪些行满足我的要求呢？条件1是部门编号是B005，条件2是性别为女，因为条件1和条件2是用AND符号连接起来的，那么只有某一行同时满足条件1和条件2的时候，这一行才会被选出来。

同样的道理可以用到第三个和第四个例子，值得一提的是第4个例子，使用的是OR符号连接起来的，所以说这俩条件任意满足一个我就可以选出这一行了

![image-20210712084101410](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084101410.png)

与选择操作不同的是，投影操作主要是选中列而不是行，投影的标识符号是Pi, 下标那些就是属性名，如果你想从职员表中挑出一些列组合在一起，那么只需要在Pi的下标那里写上属性名就可以了。

如同例子中，我只需要职员编号，姓名以及薪水，其他的属性我不需要，那么我就需要一次投影操作，从表中挑出这些列

![image-20210712084122272](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084122272.png)

新的结果中，就只剩下我需要的属性了。但是投影操作一般单独应用很少，一般会跟其他操作一起使用，接下来我就介绍一下几种基本的集合操作

![image-20210712084211978](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084211978.png)

选择操作和投影操作只从一个关系中提取信息，但是关系型数据库是需要从不同信息间提取数据的，接下来我们就会开始学习集合操作，来学习如何从不同的关系中提取信息并整合

![image-20210712084234086](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084234086.png)

从定义来说，如果关系R有x行，关系S有y行，那么他俩的并集就是他俩的合体，合体之后会进行去重，因此合并的结果最多最多是x + y行，前提是他俩没有重复的行。

![image-20210712084304660](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084304660.png)

比如这个例子里面，我想列举出哪些城市有部门办公室或者是可租的资产，那么首先我需要使用投影操作从这两个表中选择对应的城市列

![image-20210712084344754](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084344754.png)

然后合并这两列，并且在合并之后删除重复的行，得到了最终的结果。

![image-20210712084417706](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084417706.png)

值得一提的是，不是所有的关系都是可以合并的，比如这个操作中，这两个投影的结果是没办法合并的，因为第一个的属性数量是2,第二个的属性数量是1,这怎么合并嘛？除非你在Branch表中创建一个属性叫做rooms，然后使用投影的时候也一并选出来，那么这俩还是可以合并的。合并的时候必须要考虑到合并的兼容性，两个关系的属性的定义和数量必须要是一样的才可以合并。

![image-20210712084438039](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084438039.png)

与并集相反，差集则是关系之间的减法操作。假设我们有关系R和关系S，对于关系R，我们删掉所有在关系S中已经有的行，保留那些属于关系R，但是不属于关系S的行。比如右边这个例子，我们首先从Branch关系和PropertyForRent关系中抽取各自的City列，然后对这俩City关系进行差集操作，从左边的City中删除那些右边已经有的City，比如Aberdeen, Glasgow和London

![image-20210712084500215](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084500215.png)

之后我们就得到了差集的结果，也就是只剩下了布里斯托这一个选择

![image-20210712084518584](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084500216.png)

与差集颇为相似的是，交集也是以R关系为基础进行删选，不过这次要求那些同时存在与R和S的行，等同于从R中删除那些不存在于S中的行。我们可以继续使用上一个PPT中的例子。跟上一个例子不同的是，我们现在需要删除那些在第二个关系中不存在的行，也就是布里斯托了，然后把剩下的行去重，就可以得到最终的结果

![image-20210712084548760](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084548760.png)

与差集颇为相似的是，交集也是以R关系为基础进行删选，不过这次要求那些同时存在与R和S的行，等同于从R中删除那些不存在于S中的行。我们可以继续使用上一个PPT中的例子。跟上一个例子不同的是，我们现在需要删除那些在第二个关系中不存在的行，也就是布里斯托了，然后把剩下的行去重，就可以得到最终的结果

![image-20210712084610043](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084610043.png)

如果说交集并集差集就像是加法减法一样的话，那么笛卡尔积就类似于乘法了。首先从定义来看，笛卡尔积是对两个关系R和S进行操作，产生的新关系中元组也就是行的个数是两个关系中元组个数的乘积。定义非常的模糊，让我们从一个例子入手了解。首先我需要介绍两个表，这两个表应该是大多数房屋中介公司都会有的表，首先这个viewing表记录了客户看房的时候产生的一些信息，比如看房日期，客户代号，看的哪个房子，以及客户评论。

![image-20210712084647350](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084647350.png)

第二张表则记录了客户信息，比如代号、姓名等等，注意以下，属性clientNo记录了客户的编号，这个属性两张表都有，因此我们可以使用这个属性来将两张表，也就是两个关系，联系在一起。接下来我们就要使用笛卡尔积来完成一些复杂的操作，从而从这两张表中获取我们想要的信息。

![image-20210712084709255](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084709255.png)

我们想要知道那些已经看过房的客户的一些具体信息，比如名字和评论。首先根据刚刚我介绍的两张表，Viewing表有客户编号和客户评论信息，但是没有客户名字属性，Client表有客户编号和客户名字，但是没有客户评论这个属性，因此我们需要通过客户编号，将两张表结合在一起，而这个操作就是笛卡尔积。

首先我们使用投影操作从两张表中选取我们需要的属性，比如从Client表中选取客户编号和客户名字，从Viewing表中选取客户编号，房产编号以及客户评论，正如下面两张图中的红框所示，然后将两个投影的结果通过笛卡尔积结合在一起。

![image-20210712084731619](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084731619.png)

第一步，既然是结合，那么两边的属性都会被保留，因此新的表里，会有两边的属性，但是由于clientNo两个表都有，所以使用client.clientNo的方式标识来自于哪个表，然后我们可以开始合并操作了。

![image-20210712084756131](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084756131.png)

我们从Client的第一行入手，首先第一行跟Viewing第一行结合，生成新的一行，然后跟Viewing的第二行结合，生成第二行，依次下去，用Client表中的第一行乘以Viewing中的5行，生成了新的5行，如下面所示。

我们对着Client每一行重复以上操作，我们就能得到最终的结果

![image-20210712084817210](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084817210.png)

还记得笛卡尔积操作之后最终的行数是多少吗？刚刚我们将Client的每一行都乘以了Viewing的所有行，因此最终的行数就是Client的行数乘以Viewing的行数，也就是20行。如果你比较细心的话，应该能发现这张表里面，client的clientNo和Viewing的clientNo不是一一对应的，你比如第一行里面，CR76和CR56并不是一个人，因此第一行中名为John Kay的评论并不是too small, 而在第二行中，关系就完美对应了起来，从这一行里我们得知，代号CR76的名字是John Kay, 而他的评论是too remote。

从以上分析我们可以看出，这张表并不是我们要的，因为混杂了太多没有用的行，我们需要将client.clientNo等于Viewing.clientNo的行筛选出来，这时候就需要之前学过的选择操作了。

![image-20210712084842315](/home/xunjie/Study/CPT_DBS/Presentation/Lec2/img/image-20210712084842315.png)

选择的对象很简单，就是刚刚笛卡尔积生成的20行的表，选择的条件就是Client.clientNo和Viewing.clientNo要对应起来，这样能得到我们想要的最终结果。